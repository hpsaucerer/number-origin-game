import { supabase } from "@/lib/supabase";
import Home from "../index";
import cookie from "cookie";

export async function getServerSideProps(context) {
  const { puzzle_number } = context.params;

  const cookies = cookie.parse(context.req.headers.cookie || "");
  const rawDeviceId = cookies.device_id;
  const device_id = rawDeviceId?.trim().toLowerCase();

  console.log("üì¶ Received cookies:", cookies);
  console.log("üì¶ Normalized device_id:", device_id);

  if (!device_id) {
    console.warn("üö´ No device_id found in cookies. Skipping archive access.");
    return { redirect: { destination: "/archives", permanent: false } };
  }

  // üîç Check for valid archive token
  const { data: token, error: tokenError } = await supabase
    .from("archive_tokens")
    .select("*")
    .eq("device_id", device_id)
    .eq("puzzle_number", parseInt(puzzle_number))
    .eq("used", false)
    .maybeSingle();

  if (tokenError || !token) {
    console.warn("‚ö†Ô∏è No valid archive token found.");
    return { redirect: { destination: "/archives", permanent: false } };
  }

  // ‚úÖ Mark token as used
  await supabase
    .from("archive_tokens")
    .update({ used: true, used_at: new Date().toISOString() })
    .eq("id", token.id);

  // üß© Load puzzle content
  const { data, error } = await supabase
    .from("puzzles")
    .select("*")
    .eq("puzzle_number", puzzle_number)
    .single();

  if (error || !data) {
    console.error("‚ùå Puzzle not found for puzzle_number:", puzzle_number);
    return { notFound: true };
  }

  return {
    props: {
      overridePuzzle: data,
      isArchive: true,
      archiveIndex: data.puzzle_number,
    },
  };
}

export default function ArchivePuzzlePage(props) {
  return <Home {...props} />;
}
